🧪 Backend Technical Challenge – WebSockets, APIs & Concurrency
🧠 Context
At AI Tutor, we build real-time systems that process, enrich, and exchange language data across APIs and WebSockets. This challenge tests your ability to build a simple event-driven backend pipeline, handle bidirectional WebSocket communication, and work with external APIs.
________________


🧩 The Challenge
Your task is to build two components that talk to each other via WebSockets:
________________


✅ Core Scope (~3-4h)
1. Joke Server (WebSocket Server)
* Exposes a WebSocket endpoint (e.g., /ws).
* When a client connects: Every 200ms, sends a JSON message like:

{ "id": 1, "joke": "Why did the chicken cross the road?" }
* Iterates through a short static list of jokes.
* Keeps the connection open.

2. Joke Client (WebSocket Client)
   * Connects to the server’s WebSocket
   * On each incoming joke:
   * Translates the joke using an external API of your choice (e.g., LibreTranslate, DeepL, OpenAI, Google Translate).
   * Sends back a JSON response like: { "id": 1, "translated_joke": "Warum überquerte das Huhn die Straße?" }
   * Continues to Listen to the serversocket while handling the translation. Is capable of handling more than one translation at the same time.
   * Closes connection after having submitted 5 translated jokes.
________________


🧪 Bonus Tasks (Optional)
🖥 Bonus 1: Web UI
   * Implement a simple web frontend on the server side.
   * Shows real-time status of client connections:
   * #Jokes sent
   * #Translations received
   * Time taken to translate
🤖 Bonus 2: Dynamic Jokes via OpenAI API
   * Replace the static joke list with live joke generation via OpenAI or similar.
________________

🛠 Submission Guidelines
   * Language: Prefer Python or C# – others allowed with short rationale.
   * We won’t strictly track how much time you spend on the task. However, if your effort significantly deviates from the suggested ~3–4 hours, we’d appreciate a short note (e.g., when submitting).
   * Deliverables:
   * Working code (client + server)
   * Minimal setup (python main.py, dotnet run, or docker-compose up)
   * README.md with:
   * How to run the code
   * External API used (and how to get a key if needed)
   * Submit via GitHub repo or ZIP archive
________________

🔍 What We’ll Look For
      * Clean, modular, readable code
      * Proper handling of WebSocket communication
      * Clear concurrency (e.g., async or threading)
      * Use of external APIs
      * Bonus: UI, structured logging, good test scaffolding